# 移动端性能优化

 

## 初识移动端性能优化



### 什么是性能

- 页面的响应速度



页面的响应速度

- 打开页面到实际能够正常使用的时间
  - 网络请求的时间
  - 页面加载和渲染的时间
- 与页面进行交互的流畅程度
  - Javascript脚本的执行速度

ps:**更快地加载页面首屏内容，无需考虑整张页面**





### 为什么需要优化移动端的性能

- 提升用户体验
- 与PC端相比，移动端网络速度慢
- 与PC端相比，移动端设备性能低





### 学什么

- 各阶段的性能优化点
- 具体的性能优化策略



## 网络请求过程中的优化点

![image-20210808140219787](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210808140224.png)





![image-20210808153027628](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210808153058.png)



### Chrome Dev Tool 中时间线各阶段代表的意义

![img](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210808153553.png)



> 在请求能够被发出去前的等等时间。包含了用于处理代理的时间。
>
> 另外，如果有已经建立好的连接，那么这个时间还包括等待已建立连接被复用的时间，这个遵循Chrome对同一源最大6个TCP连接的规则。

#### Proxy Negotiation

- 与代理服务器连接的协商的时间。



#### DNS Lookup

- 用于执行DNS查找时间。页面上的每一个新域需要一个完整的来回做DNS查找。



#### Initial Connection / Connecting

- 用于建立链接的时间，包括TCP握手及多次尝试握手，还有处理SSL。



#### SSL

- 完成SSL握手的时间。



#### Request Sent / Sending

- 发起请求的时间



#### Waiting (TTFB)

- 请求发出后，到收到响应的第一个字节所花费的时间(Time To First Byte)



#### Content Download / Downloading

- 用于下载响应的时间





### 将多个资源分布在不同域上，减少请求队列的等待时间

- 浏览器为每个域名分配的并发通道有限
- 多个域意味着更多的DNS查询时间，通常把域名拆分到3~5个比较合适



### 通过dns-prefetch减少DNS查询时间

- 尝试在请求资源之前解析域名

![image-20210808154751054](C:\Users\云牧丫\AppData\Roaming\Typora\typora-user-images\image-20210808154751054.png)

- 仅对跨域域上的DNS查找有效
- 已经解析过的域名不要再添加dns-prefetch

![image-20210808160227620](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210808160230.png)



### 减少HTTP请求数量

- 资源的合并(合并CSS、JS文件)
- 内联首屏相关代码
- 使用缓存(浏览器缓存、localStorage 等)



```css
<!-- <link rel="stylesheet" href="./css/reset.css" />
<link rel="stylesheet" href="./css/base.css" />
<link rel="stylesheet" href="./css/index.css" /> -->

<!-- <link rel="stylesheet" href="./css/index.css" /> -->
	
<!-- 1.合并后的资源不能过大 -->
<!-- 2.考虑缓存的问题 -->
<link rel="stylesheet" href="./css/common.css" />
<link rel="stylesheet" href="./css/index.css" />
```





![image-20210808155826790](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210808155829.png)





### 减少请求资源的大小

- 资源的压缩(HTML、 CSS 的压缩以及JS的压缩和混淆)
- 开启Gzip压缩
- 减少Cookie体积

![image-20210808160820574](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210808160822.png)



![image-20210808161043125](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210808161044.png)



![image-20210808161218443](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210808161220.png)







## 页面加载和渲染过程中的优化点

![image-20210808161253990](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210809092842.png)



- CSS 一般在head中引入
- JavaScript一般在body末尾引入



![image-20210808161929826](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210808161956.png)

- 减少回流/重布局/重排(Reflow/Relayout) 与重绘(Repaint)
  - 元素的尺寸、位置、隐藏等属性改变时，浏览需要重新计算,就称为回流
  - 元素的外观、风格等属性改变时，浏览器只需要重新绘制，就称为重绘
  - 回流一定会引起重绘，重绘不一定会引起回流





## JavaScript脚本中的优化点

- DOM操作优化
- 事件优化
- 图片懒加载和预加载



## 图片优化

### 减少HTTP请求数量

- 使用CSS画图(动画)代替简单的图片(**https://www.webhek.com/post/40-css-shapes.html**)
- 合并小图标(CSS Sprites)
- 将小图标内嵌到HTML中(Base64格式的图片)



### 减少请求资源的大小

- 使用图标字体代替简单的图标
- 压缩图片
- 选择合适的图片大小
- 选择合适的图片类型



图片类型

- jpg
  - 有损压缩，压缩率高，不支持透明
  - 适用于色彩丰富、渐变色且不需要透明图片的场景
- png
  - png-8 256色+支持透明
  - png-24 2^24色+不支持透明
  - png-32 2^24色+支持透明
  - 适用于大部分需要透明图片的场景
- webp
  - 与png、jpg相比，相同的视觉体验下，图像更小
  - 支持有损压缩、无损压缩、透明和动画
  - 理论上完全可以替代png、jpg、 gif 图片格式
  - 存在一定的兼容性问题



##  动画优化

![image-20210809123441877](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210809123444.png)



- 优先使用CSS3过渡和动画
- 优先使用translate3d做运动
- 必须使用JavaScript做动画时，使用requestAnimationFrame

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>动画优化</title>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
      .mask {
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        opacity: 1;
        /* transition: opacity 0.5s; */
      }
    </style>
  </head>
  <body>
    <div id="mask" class="mask"></div>

    <script>
   		 // 使用Js搭配CSS3完成元素消失的动画
        const $mask = document.getElementById('mask');



        $mask.addEventListener(
            'click',
            function () {
                $mask.style.opacity = 0;
            },
            false
        );
        $mask.addEventListener(
            'transitionend',
            function () {
                $mask.style.display = 'none';
            },
            false
        );
    </script>
  </body>
</html>

```



- 使用JS  requestAnimationFrame 来实现
  - `window.requestAnimationFrame()` 需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行一次。

```js
$mask.addEventListener(
    "click",
    function () {
        // setTimeout(fadeOut, 20);
        requestAnimationFrame(fadeOut);
    },
    false
);

let opacity = 1;

function fadeOut() {
    opacity -= 0.05;

    if (opacity <= 0) {
        opacity = 0;
        $mask.style.display = "none";
    } else {
        requestAnimationFrame(fadeOut);
    }
    $mask.style.opacity = opacity;
}
```



## CSS优化



### **选择器优化**

- 不要使用嵌套过多过于复杂的选择器，保持简单，可以通过样式直接选择，不要画蛇添足。
- 避免过多的通配符选择器
- 移除无匹配的样式

```css
/* 较差的做法 */
ul li a {
    text-decoration: none;
}
ul.list li.list-item a.list-link {
    text-decoration: none;
} 
/* 更好的做法 */
.list-link {
    text-decoration: none;
}

/* 避免过多的通配符选择器 */
/* 少量完全可以 */
* {
    padding: 0;
    margin: 0;
} 

/* 1.4.移除无匹配的样式 */
.list {
} 
```



### **其他优化**

- 提取公用部分
- 避免使用 CSS @import 导入 CSS

```css
/* 提取公用部分 */
/* 较差的做法 */
ol {
    padding: 0;
    margin: 0;
}
p {
    padding: 0;
    margin: 0;
}
/* 更好的做法 */
ol,
p {
    padding: 0;
    margin: 0;
}

<syule>
/* 避免使用 CSS @import 导入 CSS 会发送多余的 HTTP 请求 (less sass里面的@import可以使用 因为相对于拷贝一份代码到当前页面，不会发送额外请求)*/
 @import "./reset.css";
</style>
```



## DOM优化

### 渲染优化

- 减少 DOM 元素数量和嵌套层级

- 尽量避免使用 table 布局，用其他标签代替

- table 是作为一个整体解析的，要等整个表格都解析完成才显示可能很小的一点改动，也会造成整个 table 的重新布局

  - ```html
    table {
    	width: 100%;
    	border-collapse: collapse;
    }
    th,
    td {
    	border: 1px solid #ccc;
    	text-align: center;
    }
    
    <table>
        <tr>
            <th>姓名</th>
            <th>年龄</th>
            <th>性别</th>
        </tr>
        <tr>
            <td>张三</td>
            <td>18</td>
            <td>男</td>
        </tr>
        <tr>
            <td>李四</td>
            <td>20</td>
            <td>女</td>
        </tr>
    </table>
    ```

    

### JS选择器优化

- 优先使用 id 来获取单个元素

  - ```js
    console.log(document.getElementById('box')); // 推荐
    console.log(document.querySelector('#box')); // 不推荐
    ```

- 获取多个元素时，尽量直接通过元素本身的 className 获取

  - ```js
    console.log(document.querySelectorAll('ul.list li.item')); // 不推荐
    console.log(document.getElementsByClassName('item')); // 推荐
    console.log(document.querySelectorAll('.item')); // 推荐
    ```

  


### 减少DOM操作次数

- 总是将选择器的选择结果缓存起来

  - ```js
    // 总是将选择器的选择结果缓存起来
    const $list = document.getElementById('list');
    ```




- 避免在循环中多次使用 innerHTML，在循环结束后使用一次

  - ```js
    const $list = document.getElementById('list');
    const todoDatas = ['洗衣服', '做饭', '写代码'];
    // 错误写法
    for (const item of todoDatas) {
        $list.innerHTML += `<li class="item">${item}</li>`;
    }
    
    // 正确的写法 避免在循环中多次使用 innerHTML，在循环结束后使用一次
    let html = '';
    for (const item of todoDatas) {
        html += `<li class="item">${item}</li>`;
    }
    $list.innerHTML = html;
    ```

- 新创建的元素，完成必要操作后再添加到页面中

  - ```js
    for (const item of todoDatas) {
        const $li = document.createElement("li");
    
        // 新创建的元素，完成必要操作后再添加到页面中
        $li.className = "item";
        $li.innerHTML = item;
        $li.style.color = "pink";
    
        $list.appendChild($li);
    }
    ```

- 使用 DocumentFragment 优化多次的 appendChild

  - ```js
    // 使用 DocumentFragment 优化多次的 appendChild
    const $liFragment = document.createDocumentFragment();
    
    for (const item of todoDatas) {
        const $li = document.createElement('li');
    
        $li.className = 'item';
        $li.innerHTML = item;
        $li.style.color = "pink";
    
        $liFragment.appendChild($li);
    }
    $list.appendChild($liFragment);
    ```

  

- 不要直接通过 JS 修改元素的 style，通过添加移除 class 修改元素样式

  - ```js
    <style>
        .box {
            width: 100px;
            height: 100px;
            background-color: pink;
        }
        .active {
            width: 200px;
            height: 200px;
            background-color: green;
        }
    </style>
    
     const $box = document.getElementById("box");
     // let active = false;
    $box.addEventListener(
        "click",
        () => {
            if (!active) {
                active = true;
                // $box.style.width = '200px';
                // $box.style.height = '200px';
                // $box.style.backgroundColor = 'green';
    
                $box.classList.add("active");
            } else {
                active = false;
                // $box.style.width = '100px';
                // $box.style.height = '100px';
                // $box.style.backgroundColor = 'pink';
                $box.classList.remove("active");
            }
    
            $box.classList.toggle("active");
        },
        false
    );
    ```

    

- 注意强制回流

  - **当获取的属性值包括但不限于 offsetTop、offsetLeft、scrollTop、clientTop 这些“全局属性”时，需要此时页面上的其他元素的布局和样式处于最新状态，这会引起多次的回流和重绘。这样的操作称为强制回流**
  - ![强制回流](https://raw.githubusercontent.com/xixixiaoyu/cloundImg/main/img/20210809175600.png)
  -  **https://gist.github.com/paulirish/5d52fb081b3570c81e3a**
  - **可以将其结果缓存起来，需要更新的时候再更新**

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
        <style>
            .backtop {
                position: fixed;
                right: 20px;
                bottom: 20px;
                width: 90px;
                height: 90px;
                line-height: 90px;
                text-align: center;
                background-color: rgba(0, 0, 0, 0.6);
                border-radius: 50%;
                color: #fff;
                font-size: 60px;
                text-decoration: none;
                -webkit-tap-highlight-color: transparent;
            }
            .none {
                display: none;
            }

        </style>
    </head>
    <body style="height: 5000px;">
        <a href="#" id="backtop" class="backtop">&uarr;</a>

        <script>
            // 注意强制回流
            const $backtop = document.getElementById("backtop");
            //做缓存 窗口改变的时候再重新计算
            let winHeight = window.innerHeight;

            window.addEventListener(
                "resize",
                () => {
                    winHeight = window.innerHeight;
                },
                false
            );

            window.addEventListener("scroll", scrollHandler, false);

            function scrollHandler() {
                // console.log('scroll');
                // 不推荐这样 两个属性都会造成强制回流 
                // 可以对window.innerHeight进行处理
					// if(document.documentElement.scrollTop >  window.innerHeight)
                if (document.documentElement.scrollTop >= winHeight) {
                    $backtop.classList.remove("none");
                } else {
                    $backtop.classList.add("none");
                }
            }
        </script>
    </body>
</html>
```



## 事件代理

> 什么是事件代理
> 事件代理的实现



### 什么是事件代理

- 也叫事件委托，把原本在子元素上监听的事件委托给父元素，让父元素监听 利用事件冒泡的机制



### 事件代理的实现



```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>事件代理</title>
        <style>
            * {
                box-sizing: border-box;
            }
            body {
              background-color: #f5f5f5;
          }
          .input {
              width: 100%;
              height: 40px;
              border: 1px solid #ccc;
              margin-bottom: 20px;
              font-size: 20px;
          }
          .list {
              padding: 0;
              margin: 0;
            }
            .item {
                display: flex;
                justify-content: space-between;
                padding: 0 10px;
                margin-bottom: 10px;

                background-color: #fff;

                font-size: 40px;
            }

            .del {
                text-decoration: none;
            }
        </style>
    </head>
    <body>
        <input type="text" id="input" class="input" placeholder="请输入待办事项" />
        <ul class="list" id="list">
            <li class="item">洗衣服<a href="javascript:;" class="del">x</a></li>
            <li class="item">做饭<a href="javascript:;" class="del">x</a></li>
            <li class="item">写代码<a href="javascript:;" class="del">x</a></li>
        </ul>

        <script>


            const $input = document.getElementById('input');
            const $list = document.getElementById('list');

            // 使用事件委托到父元素 性能消耗小 原理：冒泡
            $list.addEventListener(
                'click',
                evt => {
                    // console.log('click');
                    // console.log(evt.target);
                    if (evt.target.classList.contains('del')) {
                        $list.removeChild(evt.target.parentNode);
                    }
                },
                false
            );

            $input.addEventListener(
                'keypress',
                evt => {
                    // console.log(evt);
                    if (evt.keyCode === 13) {
                        // 回车
                        if (!$input.value) return;

                        const $item = document.createElement('li');
                        const $del = document.createElement('a');
                        $item.className = 'item';
                        $del.className = 'del';
                        $del.href = 'javascript:;';

                        $item.innerHTML = $input.value;
                        $del.innerHTML = 'x';
								
                        
                        // 每次创建都会给a标签绑定事件函数 消耗性能
                        // $del.addEventListener(
                        //   'click',
                        //   () => {
                        //     $list.removeChild($item);
                        //   },
                        //   false
                        // );

                        $item.appendChild($del);
                        $list.appendChild($item);

                        $input.value = '';
                    }
                },
                false
            );
        </script>
    </body>
</html>
```





## 事件稀释

> 什么是事件稀释
> 事件稀释的方法
> 	➢ 防抖
> 	➢ 节流



```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>事件稀释</title>
    <style>
      .backtop {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 90px;
        height: 90px;
        line-height: 90px;
        text-align: center;
        background-color: rgba(0, 0, 0, 0.6);
        border-radius: 50%;
        color: #fff;
        font-size: 60px;
        text-decoration: none;
        -webkit-tap-highlight-color: transparent;
      }
      .none {
        display: none;
      }
    </style>
  </head>
  <body style="height: 2000px">
    <a href="#" id="backtop" class="backtop none">&uarr;</a>

    <script>
      // 什么是事件稀释
      // 有些事件在一段时间内会多次触发，事件稀释就是减少这些事件的触发频率
      // 比如 scroll resize mousemove touchmove 等
      // window.addEventListener('scroll', handler, false);
      // window.addEventListener('resize', handler, false);
      // window.addEventListener('mousemove', handler, false);
      // window.addEventListener('touchmove', handler, false);
      // function handler(evt) {
      //   console.log(evt.type);
      // }

      // window.addEventListener('scroll', debounce(scrollHandler), false);
      window.addEventListener("scroll", throttle(scrollHandler), false);

      const $backtop = document.getElementById("backtop");
      let winHeight = window.innerHeight;

      window.addEventListener(
        "resize",
        debounce(() => {
          winHeight = window.innerHeight;
          console.log(winHeight);
        }),
        false
      );

      function scrollHandler() {
        console.log("scroll");

        if (document.documentElement.scrollTop >= winHeight) {
          $backtop.classList.remove("none");
        } else {
          $backtop.classList.add("none");
        }
      }

      // 2.防抖 debounce
      // 在某个时间期限内，事件处理函数只执行一次
      function debounce(fn, miliseconds = 250, context) {
        let timer = null;

        return function (...args) {
          const self = context || this;

          if (timer) {
            clearTimeout(timer);
          }

          timer = setTimeout(() => {
            fn.apply(self, args);
            timer = null;
          }, miliseconds);
        };
      }

      // 3.节流 throttle
      // 事件处理函数执行一次后，在某个时间期限内不再工作
      function throttle(fn, miliseconds = 250, context) {
        let lastEventTimestamp = null;

        return function (...args) {
           // 指定this 要么是传入的 否则就是当前返回函数的this
          const self = context || this;
           // 记录当前时间戳
          const now = Date.now();
			 // 如果时间戳为false值 或 当前时间 - 之前时间 >= 规定时间 则进入语句执行代码
          if (!lastEventTimestamp || now - lastEventTimestamp >= miliseconds) {
             // 更新之前时间的值
            lastEventTimestamp = now;
             // 执行传入函数 绑定this 传入args
            fn.apply(self, args);
          }
        };
      }
    </script>
  </body>
</html>
```







## 图片懒加载

### 什么是图片懒加载

-  图片懒加载又叫图片延迟（按需）加载
-  在需要的时候加载图片
-  更好的加载页面的首屏内容 无需考虑整个页面



### 图片懒加载的实现

```html
<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>图片懒加载</title>
      <style>
          * {
              padding: 0;
              margin: 0;
          }

          img {
              width: 100%;
              height: 183px;
          }
      </style>
    </head>
    <body>

    <div class="img-container">
      <img
        src="./images/loading.gif"
        alt=""
        data-src="./images/1.jpg"
        class="lazyload"
      />
    </div>
    <div class="img-container">
      <img
        src="./images/loading.gif"
        alt=""
        data-src="./images/2.jpg"
        class="lazyload"
      />
    </div>
    <div class="img-container">
      <img
        src="./images/loading.gif"
        alt=""
        data-src="./images/3.jpg"
        class="lazyload"
      />
    </div>
    <div class="img-container">
      <img
        src="./images/loading.gif"
        alt=""
        data-src="./images/4.jpg"
        class="lazyload"
      />
    </div>
    <div class="img-container">
      <img
        src="./images/loading.gif"
        alt=""
        data-src="./images/5.jpg"
        class="lazyload"
      />
    </div>

    <script>
      // 图片要设置高度
      const imgs = [...document.querySelectorAll(".lazyload")];

      lazyload();

      window.addEventListener('scroll', lazyload, false);
     


      function lazyload() {
        for (let i = 0; i < imgs.length; i++) {
          const $img = imgs[i];

          if (isInVisibleArea($img)) {
            $img.src = $img.dataset.src;
            imgs.splice(i, 1);
            i--;
          }
        }
      }

      // DOM 元素是否在可视区域内
      function isInVisibleArea($el) {
        const rect = $el.getBoundingClientRect();
        // console.log(rect);

        return (
          rect.bottom > 0 &&
          rect.top < window.innerHeight &&
          rect.right > 0 &&
          rect.left < window.innerWidth
        );
      }
     
    </script>
  </body>
</html>

```



- 加上防抖和节流进行性能优化试试

```js

 window.addEventListener("scroll", debounce(lazyload), false);

// 不适用
// window.addEventListener('scroll', throttle(lazyload), false);

// 防抖 debounce
// 在某个时间期限内，事件处理函数只执行一次
function debounce(fn, miliseconds = 250, context) {
    let timer = null;

    return function (...args) {
        const self = context || this;

        if (timer) {
            clearTimeout(timer);
        }

        timer = setTimeout(() => {
            fn.apply(self, args);
            timer = null;
        }, miliseconds);
    };
}

// 节流 throttle
// 事件处理函数执行一次后，在某个时间期限内不再工作
function throttle(fn, miliseconds = 250, context) {
    let lastEventTimestamp = null;

    return function (...args) {
        const self = context || this;
        const now = Date.now();

        if (!lastEventTimestamp || now - lastEventTimestamp >= miliseconds) {
            lastEventTimestamp = now;
            fn.apply(self, args);
        }
    };
}
```





## 图片预加载

### 什么是图片预加载

- 提前加载将来可能会用到的图片





### 图片预加载的实现



```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>图片预加载</title>
    <style>
      .img-container {
        display: flex;
        align-items: center;
        height: 100vh;
        background-color: rgba(0, 0, 0, 0.5);
      }
      img {
        width: 100%;
      }
      * {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <div class="img-container">
      <img src="./images/1.jpg" alt="图片" id="img" />
    </div>

    <script>

      const imgs = [
        './images/2.jpg',
        './images/3.jpg',
        './images/4.jpg',
        './images/5.jpg'
      ];
      let i = 0;
      const $img = document.getElementById('img');
		
      // 页面一开始调用preload加载数组的第一个元素
      preload(imgs[i])
        .then(data => {})
        .catch(() => {});

      // 点击切换
      $img.addEventListener(
        'click',
        () => {
          // 当索引小于数组length
          if (i < imgs.length) {
            // 将数组元素的src赋值给页面元素
            $img.src = imgs[i];
            // i+1 下次点击变为数组的第二个元素 依次递增
            i++;
			   // 当索引小于数组length
            if (i < imgs.length) {
              // 预加载下一个图片
              preload(imgs[i]);
            }
          } else {
            // 当 索引和 数组length相同 则数组内没元素了
            console.log('已经是最后一张了！');
          }
        },
        false
      );

      // 预加载
      function preload(src) {
        // Promise进行包装
        return new Promise((resolve, reject) => {
          // 创建一个新的图片标签
          const image = new Image();
			
          // 图片加载完成调用成功状态
          image.addEventListener('load', () => resolve(image), false);
          // 图片加载失败调用失败状态
          image.addEventListener('error', () => reject, false);
			// 将传进来的src赋值给新的图片
          image.src = src;
        });
      }
    </script>
  </body>
</html>

```





